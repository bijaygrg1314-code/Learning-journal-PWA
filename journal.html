<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Journal | Bijaya Gurung</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header></header>

  <main>
    
    <section class="journal-entry">
      <button class="collapsible">Week 2 Reflection</button>
      <div class="content">
        <p><strong>1. How did you approach mobile-first design?</strong><br>
        I began with a simple one-column layout optimized for small screens, focusing on readability and touch-friendly spacing. My goal was to ensure that content felt natural and uncluttered on mobile devices. Once the base layout was solid, I introduced media queries to adapt the design for tablets and desktops — adjusting padding, font sizes, and layout flow. This progressive enhancement strategy helped me build a responsive experience that feels intuitive across all screen sizes.</p>

        <p><strong>2. What was the most useful HTML or CSS concept you applied this week?</strong><br>
        Flexbox was a game-changer. It allowed me to align and distribute elements with precision, especially in the navbar and project cards. I also refined my use of margins and padding to create visual breathing room between sections. These small adjustments made a big difference in the overall polish of the site. I started thinking more like a designer — not just placing elements, but shaping the user’s experience.</p>

        <p><strong>3. What part of HTML or CSS did you find most challenging or confusing?</strong><br>
        Media queries were tricky at first. I struggled to understand which styles were active at different breakpoints, especially when multiple rules overlapped. I had to test my site on various screen sizes and use browser dev tools to inspect which styles were being applied. Through trial and error, I learned how to structure my CSS more clearly and use min-width logic to layer styles effectively. It was frustrating at times, but I came out with a stronger grasp of responsive design.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 3 Reflection</button>
      <div class="content">
        <p><strong>1. Which DOM selection methods did you use, and why?</strong><br>
        This week I used both <code>getElementById()</code> and <code>querySelector()</code> to target elements in my Learning Journal PWA. I chose <code>getElementById()</code> for unique elements like the date/time display and theme toggle button because it’s fast and direct. For reusable or styled components like collapsible sections, I used <code>querySelector()</code> to select by class. This gave me flexibility to apply interactivity across multiple elements without duplicating code.</p>

        <p><strong>2. What was the most challenging part about linking JavaScript with HTML?</strong><br>
        The biggest challenge was making sure my JavaScript executed only after the DOM was fully loaded. Initially, I placed the <code>&lt;script&gt;</code> tag in the <code>&lt;head&gt;</code>, which caused errors because the elements weren’t available yet. Once I moved it to the bottom of the <code>&lt;body&gt;</code>, everything worked smoothly. I also had to debug why my collapsible buttons weren’t responding — turns out I needed to wrap the event listeners inside a loop to target each button individually.</p>

        <p><strong>3. How did you test and debug your JavaScript code?</strong><br>
        I relied heavily on <code>console.log()</code> to trace values and confirm that my event listeners were firing. I also used browser dev tools to inspect elements and check if styles were being applied correctly. Testing across different screen sizes helped me catch layout issues, especially with the theme toggle button. I refined its position and shape to avoid overlapping the navbar and make it visually appealing. Each bug taught me something new about how the DOM behaves and how to write cleaner, modular code.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 4 Reflection</button>
      <div class="content">
        <p><strong>1. Which Storage, Browser, and Third‑Party APIs did you choose, and why?</strong><br>
        For Storage, I used <code>LocalStorage</code> because it’s simple and reliable for persisting journal entries and theme preferences across reloads. For the Browser API, I implemented the <code>Clipboard API</code> to let me copy entries quickly, and the <code>Notifications API</code> to give feedback when saving, deleting, or clearing entries. For the Third‑Party API, I integrated a <code>YouTube embed</code> to bring external learning content directly into my journal. These choices balanced ease of implementation with meaningful functionality.</p>

        <p><strong>2. How did you integrate each API with DOM manipulation?</strong><br>
        LocalStorage was tied to the journal form: when I save an entry, it’s pushed into storage and then rendered dynamically into the DOM. The Clipboard API was wired to “Copy” buttons on each entry, using event listeners to grab the text and copy it. The Notifications API was triggered after save, delete, and clear actions, providing system notifications (or alert fallbacks) based on user events. The YouTube embed was injected into a container via JavaScript, ensuring it loads seamlessly with the rest of the page.</p>

        <p><strong>3. What challenges did you encounter, and how did you solve them?</strong><br>
        The biggest challenge was handling <em>notification permissions</em> — browsers block notifications unless the user explicitly allows them. To solve this, I added a fallback <code>alert()</code> so feedback is always visible. Another challenge was making sure entries render correctly after delete and clear actions; I fixed this by re‑rendering the list after every storage update. Finally, embedding YouTube responsively required CSS tweaks to keep the iframe proportional across devices.</p>

        <p><strong>4. In what ways do these APIs improve your Learning Journal PWA?</strong><br>
        These APIs transformed the journal from a static site into a <strong>dynamic, interactive app</strong>. LocalStorage ensures my reflections persist across sessions, making the journal truly personal. Clipboard and Notifications improve usability by giving instant feedback and easy sharing. The YouTube embed connects my journal to external resources, enriching the learning experience. Together, they make the PWA more professional, engaging, and aligned with real‑world app functionality.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 5 Reflection</button>
      <div class="content">
        <p><strong>1. How is storing data in a JSON file different from using browser storage?</strong><br>
        Storing data in a JSON file (file-based storage) saves data permanently to the server's or user's filesystem, persisting across different browsers and cleared caches. This data can be created and updated outside the browser using server-side tools like Python. In contrast, browser storage (like LocalStorage) saves data locally within the user's specific browser instance and can only be accessed by client-side JavaScript.</p>

        <p><strong>2. How did you use Python to create or update your JSON file?</strong><br>
        I used Python with its built-in <code>json</code> module to manage the <code>reflections.json</code> file. The <code>save_entry.py</code> script first uses <code>json.load()</code> to read the existing list of reflections. It then appends a new reflection object (with a timestamp) to the list. Finally, it uses <code>json.dump()</code> to write the entire updated list back to the <code>reflections.json</code> file, effectively saving the changes and providing file persistence.</p>

        <p><strong>3. What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</strong><br>
        They are generally not the same. When running the PWA locally with a live server, the JavaScript can successfully fetch and display the entries from <code>/backend/reflections.json</code>. However, when deployed to static hosting like GitHub Pages, the browser's security rules (Same-Origin Policy) typically prevent client-side JavaScript from fetching local files, resulting in an error. Consequently, users on GitHub will likely not see the dynamically loaded JSON entries, only the static HTML structure.</p>

        <p><strong>4. What extra feature did you add to your PWA using the JSON file, and why?</strong><br>
        I added a Reflection Counter feature. This feature retrieves the reflection array from <code>reflections.json</code>, calculates its length using <code>entries.length</code>, and displays the total number of entries on the journal page. This was chosen because it provides immediate, quantifiable feedback to the user and serves as clear evidence that the JavaScript successfully fetched, parsed, and processed the new file-based JSON data.</p>
      </div>
    </section>

    <section class="journal-form">
      <h2>Add a Journal Entry (Now via Python)</h2>
      <p class="note">To add a new entry, you must run the <code>python backend/save_entry.py</code> script via your terminal. The form below is disabled as <strong>LocalStorage is replaced by the file-based JSON backend</strong>.</p>
      <form id="journal-form" style="pointer-events: none; opacity: 0.5;">
        <textarea id="journal-text" rows="6" placeholder="Run Python script to write reflection..." disabled></textarea>
        <div class="form-actions">
          <button type="submit" id="save-entry" disabled>Save Entry</button>
          <button type="button" id="clear-entries" disabled>Clear All</button>
        </div>
      </form>
    </section>

    <section class="saved-entries-section">
      <h2>Saved Entries</h2>
      <p id="reflection-count" class="note">Total Reflections: 0</p>
      <div id="saved-entries" class="saved-entries"></div>
    </section>

    <section class="thirdparty-section">
      <h2>Featured Video</h2>
      <p>A short video that refreshed my approach this week:</p>
      <div id="youtube-container" class="youtube-container"></div>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Bijaya Gurung | Learning Journal PWA</p>
  </footer>

  <script src="js/script.js"></script>
  <script src="js/storage.js"></script>
  <script src="js/browser.js"></script>
  <script src="js/thirdparty.js"></script>
  <script src="js/json_data.js"></script>
</body>
</html>
