<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Journal | Bijaya Gurung</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="manifest" href="{{ url_for('manifest') }}">

  <meta name="theme-color" content="#FF6F00">

</head>
<body>
  <header></header>

  <main>

    <section class="journal-entry">
      <button class="collapsible">Week 2 Journal Entry</button>
      <div class="content">
        <p><strong>1. How did you approach mobile-first design?</strong><br>
        I began with a simple one-column layout optimized for small screens, focusing on readability and touch-friendly spacing. My goal was to ensure that content felt natural and uncluttered on mobile devices. Once the base layout was solid, I introduced media queries to adapt the design for tablets and desktops ‚Äî adjusting padding, font sizes, and layout flow. This progressive enhancement strategy helped me build a responsive experience that feels intuitive across all screen sizes.</p>

        <p><strong>2. What was the most useful HTML or CSS concept you applied this week?</strong><br>
        Flexbox was a game-changer. It allowed me to align and distribute elements with precision, especially in the navbar and project cards. I also refined my use of margins and padding to create visual breathing room between sections. These small adjustments made a big difference in the overall polish of the site. I started thinking more like a designer ‚Äî not just placing elements, but shaping the user's experience.</p>

        <p><strong>3. What part of HTML or CSS did you find most challenging or confusing?</strong><br>
        Media queries were tricky at first. I struggled to understand which styles were active at different breakpoints, especially when multiple rules overlapped. I had to test my site on various screen sizes and use browser dev tools to inspect which styles were being applied. Through trial and error, I learned how to structure my CSS more clearly and use min-width logic to layer styles effectively. It was frustrating at times, but I came out with a stronger grasp of responsive design.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 3 Journal Entry</button>
      <div class="content">
        <p><strong>1. Which DOM selection methods did you use, and why?</strong><br>
        This week I used both <code>getElementById()</code> and <code>querySelector()</code> to target elements in my Learning Journal PWA. I chose <code>getElementById()</code> for unique elements like the date/time display and theme toggle button because it's fast and direct. For reusable or styled components like collapsible sections, I used <code>querySelector()</code> to select by class. This gave me flexibility to apply interactivity across multiple elements without duplicating code.</p>

        <p><strong>2. What was the most challenging part about linking JavaScript with HTML?</strong><br>
        The biggest challenge was making sure my JavaScript executed only after the DOM was fully loaded. Initially, I placed the <code>&lt;script&gt;</code> tag in the <code>&lt;head&gt;</code>, which caused errors because the elements weren't available yet. Once I moved it to the bottom of the <code>&lt;body&gt;</code>, everything worked smoothly. I also had to debug why my collapsible buttons weren't responding ‚Äî turns out I needed to wrap the event listeners inside a loop to target each button individually.</p>

        <p><strong>3. How did you test and debug your JavaScript code?</strong><br>
        I relied heavily on <code>console.log()</code> to trace values and confirm that my event listeners were firing. I also used browser dev tools to inspect elements and check if styles were being applied correctly. Testing across different screen sizes helped me catch layout issues, especially with the theme toggle button. I refined its position and shape to avoid overlapping the navbar and make it visually appealing. Each bug taught me something new about how the DOM behaves and how to write cleaner, modular code.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 4 Journal Entry</button>
      <div class="content">
        <p><strong>1. Which Storage, Browser, and Third‚ÄëParty APIs did you choose, and why?</strong><br>
        For Storage, I used <code>LocalStorage</code> because it's simple and reliable for persisting journal entries and theme preferences across reloads. For the Browser API, I implemented the <code>Clipboard API</code> to let me copy entries quickly, and the <code>Notifications API</code> to give feedback when saving, deleting, or clearing entries. For the Third‚ÄëParty API, I integrated a <code>YouTube embed</code> to bring external learning content directly into my journal. These choices balanced ease of implementation with meaningful functionality.</p>

        <p><strong>2. How did you integrate each API with DOM manipulation?</strong><br>
        LocalStorage was tied to the journal form: when I save an entry, it's pushed into storage and then rendered dynamically into the DOM. The Clipboard API was wired to "Copy" buttons on each entry, using event listeners to grab the text and copy it. The Notifications API was triggered after save, delete, and clear actions, providing system notifications (or alert fallbacks) based on user events. The YouTube embed was injected into a container via JavaScript, ensuring it loads seamlessly with the rest of the page.</p>

        <p><strong>3. What challenges did you encounter, and how did you solve them?</strong><br>
        The biggest challenge was handling <em>notification permissions</em> ‚Äî browsers block notifications unless the user explicitly allows them. To solve this, I added a fallback <code>alert()</code> so feedback is always visible. Another challenge was making sure entries render correctly after delete and clear actions; I fixed this by re‚Äërendering the list after every storage update. Finally, embedding YouTube responsively required CSS tweaks to keep the iframe proportional across devices.</p>

        <p><strong>4. In what ways do these APIs improve your Learning Journal PWA?</strong><br>
        These APIs transformed the journal from a static site into a <strong>dynamic, interactive app</strong>. LocalStorage ensures my reflections persist across sessions, making the journal truly personal. Clipboard and Notifications improve usability by giving instant feedback and easy sharing. The YouTube embed connects my journal to external resources, enriching the learning experience. Together, they make the PWA more professional, engaging, and aligned with real‚Äëworld app functionality.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 5 Journal Entry</button>
      <div class="content">
        <p><strong>1. How is storing data in a JSON file different from using browser storage?</strong><br>
        Storing data in a JSON file (file-based storage) saves data permanently to the server's or user's filesystem, persisting across different browsers and cleared caches. This data can be created and updated outside the browser using server-side tools like Python. In contrast, browser storage (like LocalStorage) saves data locally within the user's specific browser instance and can only be accessed by client-side JavaScript.</p>

        <p><strong>2. How did you use Python to create or update your JSON file?</strong><br>
        I used Python with its built-in <code>json</code> module to manage the <code>reflections.json</code> file. The <code>save_entry.py</code> script first uses <code>json.load()</code> to read the existing list of reflections. It then appends a new reflection object (with a timestamp) to the list. Finally, it uses <code>json.dump()</code> to write the entire updated list back to the <code>reflections.json</code> file, effectively saving the changes and providing file persistence.</p>

        <p><strong>3. What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</strong><br>
        They are generally not the same. When running the PWA locally with a live server, the JavaScript can successfully fetch and display the entries from <code>/backend/reflections.json</code>. However, when deployed to static hosting like GitHub Pages, the browser's security rules (Same-Origin Policy) typically prevent client-side JavaScript from fetching local files. I implemented graceful error handling so users on GitHub will see a fallback interface with LocalStorage entries only, while the core functionality remains intact.</p>

        <p><strong>4. What extra feature did you add to your PWA using the JSON file, and why?</strong><br>
        I added a comprehensive <strong>Journal Management Dashboard</strong> that includes advanced statistics, search functionality, and data export features. The dashboard shows real-time counts of Python vs Browser entries, total word counts, and provides search across all journal entries. I also added JSON export capability to download all entries for backup. These features demonstrate practical use of JSON data while significantly enhancing the user experience by providing insights into journal activity and easy content management.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 6 Journal Entry</button>
      <div class="content">
        <p><strong>1. Why is the frontend-backend connection important?</strong><br>
        The frontend-backend connection is the bridge between the user interface and the data logic. While my HTML and CSS provide the visual structure, they cannot permanently save data to the server on their own. The Flask backend acts as the logic layer, processing requests from the frontend to securely read and write data to the server. This connection turns my static website into a dynamic web application where data persists across different devices and sessions.</p>

        <p><strong>2. Which HTTP methods did you use in Flask, and why?</strong><br>
        I used two primary HTTP methods: <strong>GET</strong> and <strong>POST</strong>. I used the GET method to retrieve the current list of reflections from the reflections.json file so they can be displayed on the page. I used the POST method to send new journal entries from the client-side form to the server, where Flask appends them to the JSON file. This separation ensures that data retrieval and data modification are handled distinctively and securely.</p>

        <p><strong>3. What is the difference between using Flask to store/load JSON data and reading JSON directly in the browser?</strong><br>
        When reading JSON directly in the browser (client-side), the data is read-only or limited to LocalStorage, meaning changes aren't saved to the actual file on the server and are lost if the cache is cleared. By using Flask, the server has file-system access to physically write to reflections.json. This allows for true persistence‚Äîentries added by one user (or from one device) are saved permanently to the server and can be retrieved by any device accessing the PWA.</p>

        <p><strong>4. Did you face any difficulties when running your project on PythonAnywhere? How did you handle them?</strong><br>
        The biggest challenge was the directory structure. The lab instructions suggested using a specific backend folder, but the initial code examples pointed to the root directory, which caused "File Not Found" errors. I resolved this by modifying the Python path configuration to explicitly point to mysite/backend/reflections.json. I also had to update all my HTML link and script tags to use Flask's url_for() function, as standard relative paths do not work inside Flask templates.</p>

        <p><strong>5. What extra feature did you build into your PWA with Flask, and why did you add it?</strong><br>
        I integrated my <strong>Journal Management Dashboard</strong> (created in Lab 5) with the Flask backend. The dashboard now differentiates between "Browser/Local" entries and "Server/Flask" entries. I added this to provide a clear visual distinction of where data is coming from. It helps verify that the API connection is working‚Äîif the "Server" count increases, I know the backend logic is successful. It also gives the user confidence that their data is being safely archived on the server.</p>
      </div>
    </section>

    <section class="journal-entry">
      <button class="collapsible">Week 7 Journal Entry</button>
      <div class="content">
        <p><strong>1. Why is it useful to enhance your Flask app with PWA features?</strong><br>
        Enhancing the app with PWA features makes it reliable and accessible regardless of network conditions. By adding a Web App Manifest, users can install the journal to their home screen, making it feel like a native application. The Service Worker ensures that the app loads instantly on repeat visits and remains functional even when the user is offline, significantly improving the user experience compared to a standard website.</p>

        <p><strong>2. What did you use to support offline access and dynamic data?</strong><br>
        I used a <strong>Service Worker</strong> (sw.js) to intercept network requests. I implemented a caching strategy where the app attempts to fetch data from the network first (to get the latest reflections) and falls back to the <strong>Cache Storage API</strong> if the network fails. This ensures that the shell of the application (HTML, CSS, JS) and previously visited pages are always available offline.</p>

        <p><strong>3. What extra feature did you add, and why?</strong><br>
        I added a <strong>Real-time Offline Status Notification</strong> system. By using the browser's navigator.onLine property and event listeners, the app detects network changes instantly. When the user loses connection, a red notification pops up saying "You are offline," and when connection is restored, a green "Back online" message appears. I added this to improve transparency‚Äîusers need to know when they are working offline so they understand why new entries might not sync immediately.</p>

        <p><strong>4. Did you face any challenges deploying your PWA, and how did you solve them?</strong><br>
        The main challenge was the <strong>Service Worker Scope</strong>. Since my sw.js file is located in the static/js folder, it defaulted to only controlling files inside that folder. To fix this, I updated my flask_app.py to create a special route that serves the Service Worker from the root URL (/sw.js). This allowed the Service Worker to control the entire application, including the main HTML templates.</p>
      </div>
    </section>

    <!-- Lab 5: Python & JSON Backend Integration -->
    <section class="journal-management">
      <h2> Journal Statistics & Tools</h2>
      <div class="stats-container">
        <div class="stat-card">
          <h3>Total Entries</h3>
          <p id="total-entries">0</p>
        </div>
        <div class="stat-card">
          <h3>Python Entries</h3>
          <p id="python-entries">0</p>
        </div>
        <div class="stat-card">
          <h3>Browser Entries</h3>
          <p id="browser-entries">0</p>
        </div>
        <div class="stat-card">
          <h3>Total Words</h3>
          <p id="total-words">0</p>
        </div>
      </div>

      <div class="tools-container">
        <div class="search-box">
          <input type="text" id="search-entries" placeholder=" Search entries...">
        </div>
        <button id="export-json" class="tool-btn"> Export JSON</button>
        <button id="refresh-data" class="tool-btn"> Refresh Data</button>
      </div>
    </section>

    <section class="journal-form">
      <h2>Add a Journal Entry</h2>
      <div class="entry-methods">
        <div class="method-card">
          <h3> Python Method (Lab 5 - Recommended)</h3>
          <p>Run the Python script to add entries that persist in the JSON file:</p>
          <code class="terminal-command">python backend/save_entry.py</code>
          <p class="note">Entries added via Python will be available across all browsers and devices.</p>
        </div>

        <div class="method-card">
          <h3>üåê Browser Method</h3>
          <p>Use the form below for quick browser-only entries (LocalStorage):</p>
        </div>
      </div>

      <form id="journal-form">
        <textarea id="journal-text" rows="6" placeholder="Write your reflection here (minimum 10 characters)..."></textarea>
        <div class="form-actions">
          <button type="submit" id="save-entry"> Save to Browser</button>
          <button type="button" id="clear-form"> Clear Form</button>
        </div>
      </form>
    </section>

    <section class="saved-entries-section">
      <h2> Saved Entries</h2>
      <p id="reflection-count" class="note">Total Reflections: Loading...</p>
      <div id="saved-entries" class="saved-entries">
        <div class="loading">Loading entries...</div>
      </div>
    </section>

    <section class="thirdparty-section">
      <h2> Featured Learning Video</h2>
      <p>A short video that refreshed my approach this week:</p>
      <div id="youtube-container" class="youtube-container"></div>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Bijaya Gurung | Learning Journal PWA</p>
  </footer>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
  <script src="{{ url_for('static', filename='js/storage.js') }}"></script>
  <script src="{{ url_for('static', filename='js/browser.js') }}"></script>
  <script src="{{ url_for('static', filename='js/thirdparty.js') }}"></script>
</body>
</html>
